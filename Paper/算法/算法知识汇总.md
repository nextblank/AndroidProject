###2个有序列表合并后排序，要求复杂度为m+n###
    public double findMedianSortedArrays(int A[], int B[]) {  
    int l1 = A.length;  
    int l2 = B.length;  
    int [] C = new int[l1+l2];  
    int i =0,j =0,k=0;  
    while(i<l1 || j<l2){  
    if(i >= l1){  
    C[k] = B[j];  
    j++;  
    }else if(j >= l2){  
    C[k] = A[i];  
    i++;  
    }else{  
    if(A[i]<B[j]){  
       C[k] =  A[i];  
       i++;  
    }else{  
       C[k] =  B[j];  
       j++;  
    }  
    }  
    k++;  
    }  
    double median = 0,a=0,b=0;  
    k = l1+l2;  
    if(k%2 != 0){  
    median = C[(k-1)/2];  
    }else{  
    a = C[k/2];  
    b = C[k/2-1];  
    median = (a+b)/2;  
    }  
    return median;  
    }  
###求N的阶乘，用两种方法###
第一种方法:从1开始，一直递增乘到n，从而实现n！  

    package com.example;
    
    import java.math.BigDecimal;
    import java.util.Scanner;
    
    public class MyClass {
    public static BigDecimal factorial(int n) {
    BigDecimal result = new BigDecimal(1);
    BigDecimal a;
    for (int i = 2; i <= n; i++) {
    a = new BigDecimal(i);//将i转换为BigDecimal类型
    result = result.multiply(a);//不用result*a，因为BigDecimal类型没有定义*操作</span><span>
    }
    return result;
    }
    
    public static void main(String[] arguments) {
    System.out.println("输入整数");
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();//读取控制台输入的整数
    System.out.println(a + "!=" + factorial(a));
    }
    
    }
第二种方法:从n开始，一直递减乘到2，从而实现n！  

    package com.example;
    
    import java.math.BigDecimal;
    import java.util.Scanner;
    
    public class MyClass {
    public static BigDecimal factorial(BigDecimal n) {
    BigDecimal bd1 = new BigDecimal(1);//BigDecimal类型的1
    BigDecimal bd2 = new BigDecimal(2);//BigDecimal类型的2</span><span>
    BigDecimal result = bd1;//结果集，初值取1
    while (n.compareTo(bd1) > 0) {//参数大于1，进入循环
    result = result.multiply(n.multiply(n.subtract(bd1)));//实现result*（n*（n-1））
    n = n.subtract(bd2);//n-2后继续
    }
    return result;
    }
    
    public static void main(String[] arguments) {
    Scanner sc = new Scanner(System.in);
    BigDecimal n = sc.nextBigDecimal();
    System.out.print(n + "!=" + factorial(n));
    }
    
    }
第三种方法,用递归实现:f(n)=n*f(n-1),f(1)=1,递归相乘，从而实现n！  

    package com.example;
    
    import java.util.Scanner;
    import java.math.BigDecimal;
    public class MyClass {
    public static BigDecimal factorial(BigDecimal n){
    BigDecimal bd1 = new BigDecimal(1);//1
    if(n.equals(new BigDecimal(1))){
    return bd1;
    }
    else
    return n.multiply(factorial(n.subtract(bd1)));//n*f(n-1)
    }
    public static void main(String[] arguments){
    Scanner sc = new Scanner(System.in);
    BigDecimal a = sc.nextBigDecimal();
    BigDecimal result = factorial(a);
    System.out.println(a + "!=" +result);
    
    }
    
    }     
###单链表反转（递归和非递归）###
链表定义

    class ListNode {
    int val;
    ListNode next;
    
    ListNode(int x) {
    val = x;
    }
    }
非递归实现很简单，只需要遍历一遍链表，在遍历过程中，把遍历的节点一次插入到头部。  

    public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    while(head!=null){
    ListNode tmp = head.next;
    head.next = prev;
    prev = head;
    head = tmp;
    }
    return prev;
    }
递归实现：翻转head->为首的链表， 然后head变为尾部节点  

    public ListNode reverseList(ListNode head) {
    if(head==null||head.next ==null)
    return head;
    ListNode prev = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return prev;
    }

###m栋房子，买n栋，总价不高于k，有多少种方案###
    /*
     * m栋房子 买n栋 总价不高于k，有多少种方案的算法设计
     */
    public class Test {
    	private static int s = 0;//方案总种数
    /**
     * @param a 初始数组
     * @param b 存放结果的数组
     * @param bn 数组b的元素个数
     * @param k 总和不大于k
     * @return 数组b对应的数组a中的元素之和是否不大于k
     */
    public static boolean isMatch(int a[], int b[], int bn, int k) {
    int ret = 0;
    for (int i = 0; i < bn; i++) {
    ret += a[b[i]];
    }
    return ret <= k;
    }
    
    /**
     * @param a 初始数组
     * @param m a包含的元素个数
     * @param n 选出元素的个数
     * @param b 存放结果的数组
     * @param bn 数组b的元素个数，等于n
     * @param k 总和不大于k
     */
    public static void combine(int a[], int m, int n, int b[], int bn, int k) {
    for (int i = m; i >= n; i--) {
    b[n - 1] = i - 1;
    if (n > 1) { // 一共选n个数，n = 1时结束递归
    combine(a, i - 1, n - 1, b, bn, k);
    } else {
    if (isMatch(a, b, bn, k)) {
    	s++;
    System.out.print("第"+s+"种方案选取数据为：");
    for (int j = bn - 1; j >= 0; j--) {
    System.out.print(a[b[j]]+" ");
    }
    System.out.println("");
    }
    }
    }
    }
    
    public static void main(String[] args) {
    int[] as = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
    combine(as, 15, 5, new int[5], 5, 16);
    System.out.println("一共有"+s+"种选取方案");
    }
    }
    