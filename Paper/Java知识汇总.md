###获取时间戳最快的方法###
目前获取毫秒值大概有下面三种方法  

    //方法 一  
    System.currentTimeMillis();   
    //方法 二  
    Calendar.getInstance().getTimeInMillis();  
    //方法 三  
    new Date().getTime(); 
结果发现 System.currentTimeMillis() 这种方式速度最快  
Calendar.getInstance().getTimeInMillis() 这种方式速度最慢,看看源码会发现，Canlendar因为要处理时区问题会耗费很多的时间。  
所以建议多使用第一种方式。
###synchronized与static synchronized的区别###
synchronized是对类的当前实例（当前对象）进行加锁，防止其他线程同时访问该类的该实例的所有。  
synchronized块，注意这里是“类的当前实例”，类的两个不同实例就没有这种约束了。  
那么static synchronized恰好就是要控制类的所有实例的并发访问，static synchronized是限制多线程中该类的所有实例同时访问jvm中该类所对应的代码块。实际上，在类中如果某方法或某代码块中有synchronized，那么在生成一个该类实例后，该实例也就有一个监视块，防止线程并发访问该实例的synchronized保护块，而static synchronized则是所有该类的所有实例公用得一个监视块，这就是他们两个的区别。也就是说synchronized相当于 this.synchronized，而static synchronized相当于Something.synchronized。
###抽象类和接口###
1.接口只是给出方法，但不实现任何的方法；抽象类则可以实现部分的方法。  
2.类只能继承一个父类，但可以实现多个接口（这是Java实现多重继承的一个方法）。  
1.抽象类和接口都是用来抽象具体对象的,但是接口的抽象级别最高。  
2.抽象类可以有具体的方法和属性,接口只能有抽象方法和不可变常量。  
3.抽象类主要用来抽象类别,接口主要用来抽象功能。  
4、抽象类中,且不包含任何实现,派生类必须覆盖它们。接口中所有方法都必须是未实现的。  
当你关注一个事物的本质的时候,用抽象类；当你关注一个操作的时候，用接口。  
###反射的理解###
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。  
Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法。  
利用反射机制能获得什么信息?类中有什么信息，它就可以获得什么信息，不过前提是得知道类的名字。  

    首先得根据传入的类的全名来创建Class对象。  
    Class c=Class.forName("className");注明：className必须为全名，也就是得包含包名，比如，cn.netjava.pojo.UserInfo;
    Object obj=c.newInstance();//创建对象的实例
    OK，有了对象就什么都好办了，想要什么信息就有什么信息了。  
    获得构造函数的方法
    Constructor getConstructor(Class[] params)//根据指定参数获得public构造器
    Constructor[] getConstructors()//获得public的所有构造器
    Constructor getDeclaredConstructor(Class[] params)//根据指定参数获得public和非public的构造器
    Constructor[] getDeclaredConstructors()//获得public的所有构造器
    获得类方法的方法
    Method getMethod(String name, Class[] params),根据方法名，参数类型获得方法
    Method[] getMethods()//获得所有的public方法
    Method getDeclaredMethod(String name, Class[] params)//根据方法名和参数类型，获得public和非public的方法
    Method[] getDeclaredMethods()//获得所以的public和非public方法
    获得类中属性的方法
    Field getField(String name)//根据变量名得到相应的public变量
    Field[] getFields()//获得类中所以public的方法
    Field getDeclaredField(String name)//根据方法名获得public和非public变量
    Field[] getDeclaredFields()//获得类中所有的public和非public方法
    Java的反射非常强大，传递class， 可以动态的生成该类、取得这个类的所有信息，包括里面的属性、方法以及构造函数等，甚至可以取得其父类或父接口里面的内容。
    obj.getClass().getDeclaredMethods();//取得obj类中自己定义的方法， 包括私有的方法。
    obj.getClass().getMethods();//取得obj类中自己定义的方法及继承过来的方法， 但私有方法得不到。
    同样， 对field也是一样，obj.getClass().getDeclaredFields();取得的是这个类中所有的属性，包括私有的field; 对obj.getClass().getFields();//取得是自己以及接继承来的属性， 但不能取得自己的私有属性。
###进程和线程的区别与联系###
- **定义**  
- 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.  
- 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
- **关系**  
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
- **区别**  
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。  
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.  
2) 线程的划分尺度小于进程，使得多线程程序的并发性高。  
3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。  
4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。  
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
- **优缺点**  
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
###线程同步和异步###
同步就是指一个线程要等待上一个线程执行完之后才开始执行当前的线程。  
异步是指一个线程去执行，它的下一个线程不必等待它执行完就开始执行。  
- **区别**  
一个进程启动的多个不相干线程，它们相互之间关系为异步。  
同步指的是多线程同时操作一个数据，这个时候需要对数据添加保护，这个保护就是线程的同步。  
- **同步机制**  
临界区、互斥区、事件、信号量四种方式  
临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件（Event）的区别   
1、临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。   
2、互斥量：采用互斥对象机制。只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。   
3、信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目   
4、事件：通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作  
1、首先明确一点，对于单核CPU，任意一个时刻只有一个线程在运行。那么既然这样，多线程还有什么意义呢？ 举例来说，现在只有一个人，要做好几个任务。单线程就是，任务一个一个地做，必须做完一个任务后，再去做另一个任务。多线程就是一会做这个任务，一会做那个任务，每个任务做一会，不停的切换。显然，最后把所有的任务做完，多线程必定比单线程更耗费时间。为什么？因为，多线程要在不同的任务之间切换，切换肯定是要耗费时间的。那么问题来了，既然多线程比单线程更耗费时间，为什么还要多线程？  
单线程有一个致命的问题，就是一个线程运行的整个过程中，其他线程必须等待，不能响应用户的命令，用户体验太差，好像电脑死机一样。假如单线程，你能想象一下，用户在听歌的时候不能写文档，这种体验也太差了。多线程的时候，单核CPU一会做这个任务，一会做那个任务，切换的时间是毫秒级的，用户完全感觉不出来。从而给用户照成错觉，感觉这些任务并行的运行。  
2、同步的使用场景：多个线程同时访问一块数据，也叫共享区。对于多个线程同时访问一块数据的时候，必须使用同步，否则可能会出现不安全的情况。比如数据库中的脏读。但是，多个线程同时访问一块数据，有一种情况不需要同步技术，那就是原子操作，也就是说操作系统在底层保证了操作要么全部做完，要么不做。  
3、异步的使用场景：只有一个线程访问当前的数据。比如，观察者模式，没有共享区，主题发生变化，通知观察者更新，主题继续做自己的事情，不需要等待观察者更新完成后再工作。  
###Java容器有哪些###
在书写程序的时候，我们常常需要对大量的对象引用进行管理。为了实现有效的归类管理，我们常常将同类的引用放置在同一数据容器中。  
由于数据容器中存放了我们随时可能需要使用到的对象引用，所以一般的数据容器要都要能能提供方便的查询、遍历、修改等基本接口功能。  
早期的OOP语言都通过数组的方式来实现对引用集的集中管理和维护。  
但是数组方式下，数组大小需要提前被确定，并不允许修改大小，导致其作为一种灵活的数据容器的能力的功能大为下降。  
为了方便的利用数据容器进行引用的管理,Java中提供了丰富的数据容器以满足程序员多样化的需求。  
JAVA的容器---List,Map,Set   
Collection   
├List   
│├LinkedList   
│├ArrayList   
│└Vector   
│　└Stack   
└Set   
Map   
├Hashtable   
├HashMap   
└WeakHashMap  
！其中的Vector和Stack类现在已经极少使用。  
从容器类图中可以发现，数据容器主要分为了两类：  
Collection: 存放独立元素的序列。  
Map：存放key-value型的元素对。（这对于一些需要利用key查找value的程序十分的重要！）  
从类体系图中可以看出，Collection定义了Collection类型数据的最基本、最共性的功能接口，而List对该接口进行了拓展。  
其中各个类的适用场景有很大的差别，在使用时，应该根据需要灵活的进行选择。此处介绍最为常用的四个容器：  
LinkedList ：其数据结构采用的是链表，此种结构的优势是删除和添加的效率很高，但随机访问元素时效率较ArrayList类低。  
ArrayList：其数据结构采用的是线性表，此种结构的优势是访问和查询十分方便，但添加和删除的时候效率很低。  
HashSet: Set类不允许其中存在重复的元素（集），无法添加一个重复的元素（Set中已经存在）。HashSet利用Hash函数进行了查询效率上的优化，其contain（）方法经常被使用，以用于判断相关元素是否已经被添加过。  
HashMap: 提供了key-value的键值对数据存储机制，可以十分方便的通过键值查找相应的元素，而且通过Hash散列机制，查找十分的方便。  
###ArrayList Vector LinkList的存储性能和特性、扩容机制###
ArrayList 和Vector他们底层的实现都是一样的，都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。  
Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。  
LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。  
Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。  
ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！  
可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。  
- **总结：**  
ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下：   
1．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。  
2．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。  
3．LinkedList不支持高效的随机元素访问。  
4．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间  
ArrayList和Vector的区别：  
这两个类都实现了List接口他们都是有序集合，及存储在这两个集合中的元素位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的。  
1、同步性：  
Vector是线程安全的，也就是说它的方法之间是线程同步的，而ArrayList是线程不安全的，它的方法之间不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList因为它不考虑线程安全，效率高。如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。  
2、数据增长：  
ArrayList 与Vector 都有一个初始的容量大小，当存储进他们里面的元素个数超过了容量时，就需要增加ArrayList与Vector的存储空间， 每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取的一定的平衡。Vector默认增加为原来的两倍，而ArrayList默认为 1.5倍，ArrayList和Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而Arraylist 没有设置增长空间的方法。及Vector增长原来的1倍，Arraylist增长原来的0.5倍
###Java四种引用包括强引用，软引用，弱引用，虚引用###
在JDK1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于可触及（reachable）状态，程序才能使用它。从JDK1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。  
- **强引用（StrongReference）**  
强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  ps：强引用其实也就是我们平时A a = new A()这个意思。  
- **软引用（SoftReference）**  
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。  
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。  
- **弱引用（WeakReference）**  
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。  
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。  
- **虚引用（PhantomReference）**  
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。  
虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。  

    ReferenceQueue queue = new ReferenceQueue ();
    PhantomReference pr = new PhantomReference (object, queue); 
程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。  
###Java多线程实现的三种方式###
Java多线程实现方式主要是有三种:继承thread类,实现Runnable接口,使用ExecutorService,Callable,Future实现有返回结果的多线程,其中前两种方式线程执行完后都没有返回值，只有最后一种才有返回值  
 **继承Thread类实现多线程**
 
    public class MyThread extends Thread{
      public void run(){
       System.out.println("MyThread run()");
       }
    }
     在合适的地方启动多线程如下:
     MyThread myThread=new MyThread();
    myThread.start();
 **实现Runnable接口方法实现多线程**  
 
    public class MyThread extends otherClass implements Runnable{
    public void run(){
      Systrm.out.println("MyThread run()");
     }
    }
    为了启动Mythread ,需要首先实例化一个MyThread 
    MyThread myThread=new MyThread();
    thread thread=new Thread(myThread);
    thread.start();
 **使用ExecutorService、Callable、Future实现有返回结果的多线程**  
ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。下面提供了一个完整的有返回结果的多线程测试例子，在JDK1.5下验证过没问题可以直接使用。代码如下：

    import java.util.concurrent.*;  
    import java.util.Date;  
    import java.util.List;  
    import java.util.ArrayList;  
    /** 
    * 有返回值的线程 
    */  
    @SuppressWarnings("unchecked")  
    public class Test {  
    public static void main(String[] args) throws ExecutionException,  
    InterruptedException {  
       System.out.println("----程序开始运行----");  
       Date date1 = new Date();  
      
       int taskSize = 5;  
       // 创建一个线程池  
       ExecutorService pool = Executors.newFixedThreadPool(taskSize);  
       // 创建多个有返回值的任务  
       List<Future> list = new ArrayList<Future>();  
       for (int i = 0; i < taskSize; i++) {  
    Callable c = new MyCallable(i + " ");  
    // 执行任务并获取Future对象  
    Future f = pool.submit(c);  
    // System.out.println(">>>" + f.get().toString());  
    list.add(f);  
       }  
       // 关闭线程池  
       pool.shutdown();  
      
       // 获取所有并发任务的运行结果  
       for (Future f : list) {  
    // 从Future对象上获取任务的返回值，并输出到控制台  
    System.out.println(">>>" + f.get().toString());  
       }  
      
       Date date2 = new Date();  
       System.out.println("----程序结束运行----，程序运行时间【"  
     + (date2.getTime() - date1.getTime()) + "毫秒】");  
    }  
    }  
      
    class MyCallable implements Callable<Object> {  
    private String taskNum;  
      
    MyCallable(String taskNum) {  
       this.taskNum = taskNum;  
    }  
      
    public Object call() throws Exception {  
       System.out.println(">>>" + taskNum + "任务启动");  
       Date dateTmp1 = new Date();  
       Thread.sleep(1000);  
       Date dateTmp2 = new Date();  
       long time = dateTmp2.getTime() - dateTmp1.getTime();  
       System.out.println(">>>" + taskNum + "任务终止");  
       return taskNum + "任务返回运行结果,当前任务时间【" + time + "毫秒】";  
    }  
    }  
代码说明：
上述代码中Executors类，提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。
public static ExecutorService newFixedThreadPool(int nThreads)   
创建固定数目线程的线程池。  
public static ExecutorService newCachedThreadPool()   
创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。  
public static ExecutorService newSingleThreadExecutor()   
创建一个单线程化的Executor。  
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)   
创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。  
ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。
###Java垃圾回收机制###
1. 垃圾回收的意义    
在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是"无用信息"，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。  
垃圾回收能自动释放内存空间，减轻编程的负担。这使Java 虚拟机具有一些优点。首先，它能使编程效率提高。在没有垃圾回收机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾回收机制可大大缩短时间。其次是它保护程序的完整性，垃圾回收是Java语言安全性策略的一个重要部份。  
垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。  
2. 垃圾收集的算法分析  
Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。  
大多数垃圾回收算法使用了根集(root set)这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。垃圾回收首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。下面介绍几个常用的算法。  
2.1. 引用计数法(Reference Counting Collector)  
引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。    
基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域生，计数器减1。    
2.2. tracing算法(Tracing Collector)    
tracing算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.  
2.3. compacting算法(Compacting Collector)    
为了解决堆碎片问题，基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。  
2.4. copying算法(Coping Collector)  
该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。  
一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象区和空闲区域区，在对象区与空闲区域的切换过程中，程序暂停执行。  
2.5. generation算法(Generational Collector)  
stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。  
2.6. adaptive算法(Adaptive Collector)  
在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。  
3. System.gc()方法  
命令行参数透视垃圾收集器的运行  
使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：  
    java -verbosegc classfile  
可以看个例子：  

    class TestGC  
    {  
    public static void main(String[] args)  
    {  
    　　new TestGC();  
    　　System.gc();  
    　　System.runFinalization();  
    　　 }  
    }  
在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为不可达，程序编译后，执行命令： java -verbosegc TestGC 后结果为：  
[Full GC 168K->97K(1984K)， 0.0253873 secs]  
机器的环境为，Windows 2000 + JDK1.3.1，箭头前后的数据168K和97K分别表示垃圾收集GC前后所有存活对象使用的内存容量，说明有168K-97K=71K的对象容量被回收，括号内的数据1984K为堆内存的总容量，收集所需要的时间是0.0253873秒（这个时间在每次执行的时候会有所不同）。  
需要注意的是，调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。  
4. finalize()方法  
在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。它的原型为：  
`protected void finalize() throws Throwable`  
在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。  
之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。  
特殊的区域例如：1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。  
换言之，finalize()的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在JAVA中并没有提够像“析构”函数或者类似概念的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是override Object这个类中的finalize()方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么这个图像就会被一直保存下来。  
一旦垃圾回收器准备好释放对象占用的存储空间，首先会去调用finalize()方法进行一些必要的清理工作。只有到下一次再进行垃圾回收动作的时候，才会真正释放这个对象所占用的内存空间。  
在普通的清除工作中，为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这与C++"析构函数"的概念稍有抵触。在C++中，所有对象都会破坏（清除）。或者换句话说，所有对象都"应该"破坏。若将C++对象创建成一个本地对象，比如在堆栈中创建（在Java中是不可能的，Java都在堆中），那么清除或破坏工作就会在"结束花括号"所代表的、创建这个对象的作用域的末尾进行。若对象是用new创建的（类似于Java），那么当程序员调用C++的 delete命令时（Java没有这个命令），就会调用相应的析构函数。若程序员忘记了，那么永远不会调用析构函数，我们最终得到的将是一个内存"漏洞"，另外还包括对象的其他部分永远不会得到清除。  
相反，Java不允许我们创建本地（局部）对象--无论如何都要使用new。但在Java中，没有"delete"命令来释放对象，因为垃圾回收器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾回收机制，所以Java没有析构函数。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对析构函数的需要，或者说不能消除对析构函数代表的那种机制的需要（原因见下一段。另外finalize()函数是在垃圾回收器准备释放对象占用的存储空间的时候被调用的，绝对不能直接调用finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java中的一个方法。它等价于C++的析构函数，只是没后者方便。  
在C++中所有的对象运用delete()一定会被销毁，而JAVA里的对象并非总会被垃圾回收器回收。In another word, 1 对象可能不被垃圾回收，2 垃圾回收并不等于“析构”，3 垃圾回收只与内存有关。也就是说，并不是如果一个对象不再被使用，是不是要在finalize()中释放这个对象中含有的其它对象呢？不是的。因为无论对象是如何创建的，垃圾回收器都会负责释放那些对象占有的内存。  
5. 触发主GC（Garbage Collector）的条件  
JVM进行次GC的频率很高,但因为这种GC占用时间极短,所以对系统产生的影响不大。更值得关注的是主GC的触发条件,因为它对系统影响很明显。总的来说,有两个条件会触发主GC:  
1)当应用程序空闲时,即没有应用线程在运行时,GC会被调用。因为GC在优先级最低的线程中进行,所以当应用忙时,GC线程就不会被调用,但以下条件除外。  
2)Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。  
由于是否进行主GC由JVM根据系统环境决定,而系统环境在不断的变化当中,所以主GC的运行具有不确定性,无法预计它何时必然出现,但可以确定的是对一个长期运行的应用来说,其主GC是反复进行的。  
6. 减少GC开销的措施  
根据上述GC的机制,程序的运行会直接影响系统环境的变化,从而影响GC的触发。若不针对GC的特点进行设计和编码,就会出现内存驻留等一系列负面影响。为了避免这些影响,基本的原则就是尽可能地减少垃圾和减少GC过程中的开销。具体措施包括以下几个方面:  
(1)不要显式调用System.gc()  
此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。  
(2)尽量减少临时对象的使用  
临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。  
(3)对象不用时最好显式置为Null  
一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。  
(4)尽量使用StringBuffer,而不用String来累加字符串  
由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。  
(5)能用基本类型如Int,Long,就不用Integer,Long对象  
基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。  
(6)尽量少用静态对象变量  
静态变量属于全局变量,不会被GC回收,它们会一直占用内存。  
(7)分散对象创建或删除的时间  
集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。  
下面这个例子向大家展示了垃圾收集所经历的过程，并对前面的陈述进行了总结。
 
       class Chair {  
    　　static boolean gcrun = false;  
    　　static boolean f = false;  
    　　static int created = 0;  
    　　static int finalized = 0;  
    　　int i;  
    　　Chair() {  
    　　i = ++created;  
    　　if(created == 47)  
    　　　  System.out.println("Created 47");  
    　　}  
    　　protected void finalize() {  
    　　if(!gcrun) {  
    　　　  gcrun = true;  
    　　　  System.out.println("Beginning to finalize after " + created + " Chairs have been created");  
    　　}  
    　　if(i == 47) {  
    　　　  System.out.println("Finalizing Chair #47， " +"Setting flag to stop Chair creation");  
    　　　  f = true;  
    　　}  
    　　finalized++;  
    　　if(finalized >= created)  
    　　　  System.out.println("All " + finalized + " finalized");  
    　　}  
    }  
      
    public class Garbage {  
    　　public static void main(String[] args) {  
    　　if(args.length == 0) {  
    　　　  System.err.println("Usage: /n" + "java Garbage before/n or:/n" + "java Garbage after");  
    　　　  return;  
    　　}  
    　　while(!Chair.f) {  
    　　　  new Chair();  
    　　　  new String("To take up space");  
    　　}  
    　　System.out.println("After all Chairs have been created:/n" + "total created = " + Chair.created +  
    　　"， total finalized = " + Chair.finalized);  
    　　if(args[0].equals("before")) {  
    　　　　System.out.println("gc():");  
    　　　　System.gc();  
    　　　　System.out.println("runFinalization():");  
    　　　　System.runFinalization();  
    　　}  
    　　System.out.println("bye!");  
    　　if(args[0].equals("after"))  
    　　　  System.runFinalizersOnExit(true);  
    　　}  
    }  
    
上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。另两个static变量--created以及 finalized--分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非 static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。  
7. 关于垃圾回收的几点补充  
经过上述的说明，可以发现垃圾回收有以下的几个特点：  
（1）垃圾收集发生的不可预知性：由于实现了不同的垃圾回收算法和采用了不同的收集机制，所以它有可能是定时发生，有可能是当出现系统空闲CPU资源时发生，也有可能是和原始的垃圾收集一样，等到内存消耗出现极限时发生，这与垃圾收集器的选择和具体的设置都有关系。  
（2）垃圾收集的精确性：主要包括2 个方面：（a）垃圾收集器能够精确标记活着的对象；（b）垃圾收集器能够精确地定位对象之间的引用关系。前者是完全地回收所有废弃对象的前提，否则就可能造成内存泄漏。而后者则是实现归并和复制等算法的必要条件。所有不可达对象都能够可靠地得到回收，所有对象都能够重新分配，允许对象的复制和对象内存的缩并，这样就有效地防止内存的支离破碎。  
（3）现在有许多种不同的垃圾收集器，每种有其算法且其表现各异，既有当垃圾收集开始时就停止应用程序的运行，又有当垃圾收集开始时也允许应用程序的线程运行，还有在同一时间垃圾收集多线程运行。  
（4）垃圾收集的实现和具体的JVM 以及JVM的内存模型有非常紧密的关系。不同的JVM 可能采用不同的垃圾收集，而JVM 的内存模型决定着该JVM可以采用哪些类型垃圾收集。现在，HotSpot 系列JVM中的内存系统都采用先进的面向对象的框架设计，这使得该系列JVM都可以采用最先进的垃圾收集。  
（5）随着技术的发展，现代垃圾收集技术提供许多可选的垃圾收集器，而且在配置每种收集器的时候又可以设置不同的参数，这就使得根据不同的应用环境获得最优的应用性能成为可能。  
针对以上特点，我们在使用的时候要注意：  
（1）不要试图去假定垃圾收集发生的时间，这一切都是未知的。比如，方法中的一个临时对象在方法调用完毕后就变成了无用对象，这个时候它的内存就可以被释放。  
（2）Java中提供了一些和垃圾收集打交道的类，而且提供了一种强行执行垃圾收集的方法--调用System.gc()，但这同样是个不确定的方法。Java 中并不保证每次调用该方法就一定能够启动垃圾收集，它只不过会向JVM发出这样一个申请，到底是否真正执行垃圾收集，一切都是个未知数。  
（3）挑选适合自己的垃圾收集器。一般来说，如果系统没有特殊和苛刻的性能要求，可以采用JVM的缺省选项。否则可以考虑使用有针对性的垃圾收集器，比如增量收集器就比较适合实时性要求较高的系统之中。系统具有较高的配置，有比较多的闲置资源，可以考虑使用并行标记/清除收集器。  
（4）关键的也是难把握的问题是内存泄漏。良好的编程习惯和严谨的编程态度永远是最重要的，不要让自己的一个小错误导致内存出现大漏洞。  
（5）尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域(scope)后，自动设置为null，暗示垃圾收集器来收集该对象，还必须注意该引用的对象是否被监听，如果有，则要去掉监听器，然后再赋空值。